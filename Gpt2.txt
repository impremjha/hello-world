Let's break this down into two parts:  

1. **Lexer**: Tokenizes the input into meaningful elements (identifiers, numbers, strings, function names, brackets, etc.).  
2. **Parser**: Identifies functions and their arguments, ensuring valid syntax.

---

### **Step 1: Define Token Types**
We need to define tokens for:
- **Function Names** (e.g., `Function1`, `Function2`)
- **Identifiers** (e.g., `[var1.var1]`)
- **Strings** (e.g., `'avg'`, `'value'`)
- **Numbers** (e.g., `0`, `5.2`)
- **Operators** (e.g., `=` in `Function2`)
- **Brackets** (`(`, `)`, `,`)

---

### **Step 2: Implement the Lexer**
The lexer reads characters and groups them into tokens.

```java
import java.util.*;
import java.util.regex.*;

class Token {
    enum Type {
        FUNCTION, IDENTIFIER, STRING, NUMBER, OPERATOR, LPAREN, RPAREN, COMMA, EQUAL, UNKNOWN
    }

    Type type;
    String value;

    Token(Type type, String value) {
        this.type = type;
        this.value = value;
    }

    @Override
    public String toString() {
        return type + "('" + value + "')";
    }
}

class Lexer {
    private static final Pattern TOKEN_PATTERNS = Pattern.compile(
            "(?<FUNCTION>[A-Za-z][A-Za-z0-9_]*)" +      // Function names
            "|(?<IDENTIFIER>\\[\\w+(\\.\\w+)*\\])" +    // Identifiers like [var1.var1]
            "|(?<STRING>'[^']*')" +                     // Strings like 'avg'
            "|(?<NUMBER>\\d+(\\.\\d+)?)" +              // Numbers (integers or decimals)
            "|(?<EQUAL>=)" +                            // Equal sign
            "|(?<COMMA>,)" +                            // Comma
            "|(?<LPAREN>\\()" +                         // Left Parenthesis
            "|(?<RPAREN>\\))"                           // Right Parenthesis
    );

    private final Matcher matcher;
    
    Lexer(String input) {
        matcher = TOKEN_PATTERNS.matcher(input);
    }

    List<Token> tokenize() {
        List<Token> tokens = new ArrayList<>();
        while (matcher.find()) {
            if (matcher.group("FUNCTION") != null) tokens.add(new Token(Token.Type.FUNCTION, matcher.group()));
            else if (matcher.group("IDENTIFIER") != null) tokens.add(new Token(Token.Type.IDENTIFIER, matcher.group()));
            else if (matcher.group("STRING") != null) tokens.add(new Token(Token.Type.STRING, matcher.group()));
            else if (matcher.group("NUMBER") != null) tokens.add(new Token(Token.Type.NUMBER, matcher.group()));
            else if (matcher.group("EQUAL") != null) tokens.add(new Token(Token.Type.EQUAL, matcher.group()));
            else if (matcher.group("COMMA") != null) tokens.add(new Token(Token.Type.COMMA, matcher.group()));
            else if (matcher.group("LPAREN") != null) tokens.add(new Token(Token.Type.LPAREN, matcher.group()));
            else if (matcher.group("RPAREN") != null) tokens.add(new Token(Token.Type.RPAREN, matcher.group()));
            else tokens.add(new Token(Token.Type.UNKNOWN, matcher.group()));
        }
        return tokens;
    }
}
```

---

### **Step 3: Implement the Parser**
The parser uses tokens to identify function calls and their arguments.

```java
class Parser {
    private final List<Token> tokens;
    private int position = 0;

    Parser(List<Token> tokens) {
        this.tokens = tokens;
    }

    void parse() {
        while (position < tokens.size()) {
            parseFunction();
        }
    }

    private void parseFunction() {
        if (match(Token.Type.FUNCTION)) {
            Token functionName = previous();
            System.out.println("Function: " + functionName.value);

            if (match(Token.Type.LPAREN)) {
                List<String> args = parseArguments();
                System.out.println("Arguments: " + args);
            } else {
                throw new RuntimeException("Expected '(' after function name.");
            }
        } else {
            throw new RuntimeException("Expected function name.");
        }
    }

    private List<String> parseArguments() {
        List<String> args = new ArrayList<>();
        while (!match(Token.Type.RPAREN) && position < tokens.size()) {
            if (match(Token.Type.IDENTIFIER, Token.Type.STRING, Token.Type.NUMBER)) {
                args.add(previous().value);
            } else if (match(Token.Type.EQUAL)) {
                args.add("=");
            } else if (match(Token.Type.COMMA)) {
                // Skip commas
            } else {
                throw new RuntimeException("Unexpected token in arguments: " + peek().value);
            }
        }
        return args;
    }

    private boolean match(Token.Type... types) {
        if (position < tokens.size()) {
            for (Token.Type type : types) {
                if (tokens.get(position).type == type) {
                    position++;
                    return true;
                }
            }
        }
        return false;
    }

    private Token previous() {
        return tokens.get(position - 1);
    }

    private Token peek() {
        return tokens.get(position);
    }
}
```

---

### **Step 4: Run the Parser**
```java
public class Main {
    public static void main(String[] args) {
        String input = "Function1([var1.var1],[var2],'avg')\n"
                     + "Function2([var1.var1],[var2] = 'value')\n"
                     + "Function3([var1.var1],0)";

        Lexer lexer = new Lexer(input);
        List<Token> tokens = lexer.tokenize();
        
        System.out.println("Tokens:");
        tokens.forEach(System.out::println);
        
        System.out.println("\nParsing...");
        Parser parser = new Parser(tokens);
        parser.parse();
    }
}
```

---

### **Output Example**
```
Tokens:
FUNCTION('Function1')
LPAREN('(')
IDENTIFIER('[var1.var1]')
COMMA(',')
IDENTIFIER('[var2]')
COMMA(',')
STRING('avg')
RPAREN(')')
FUNCTION('Function2')
LPAREN('(')
IDENTIFIER('[var1.var1]')
COMMA(',')
IDENTIFIER('[var2]')
EQUAL('=')
STRING('value')
RPAREN(')')
FUNCTION('Function3')
LPAREN('(')
IDENTIFIER('[var1.var1]')
COMMA(',')
NUMBER('0')
RPAREN(')')

Parsing...
Function: Function1
Arguments: [[var1.var1], [var2], 'avg']
Function: Function2
Arguments: [[var1.var1], [var2], =, 'value']
Function: Function3
Arguments: [[var1.var1], 0]
```

---

### **How This Works**
1. **Lexer**: Converts input into tokens.
2. **Parser**: Reads tokens and identifies functions and arguments.

This approach allows us to extend parsing to support additional syntax, operators, or nested expressions later.

Would you like to add support for nested function calls or expressions within arguments?






I'll modify the lexer to handle spaces properly:

1. **Ignore spaces outside of tokens** (so expressions like `Function1 ( [var1.var1] , [var2] , 'avg' )` are parsed correctly).
2. **Allow spaces within identifiers** inside `[]` (e.g., `[var1 var2.var1 var2]` should be treated as a single token).

### **Updated Lexer**
```java
import java.util.*;
import java.util.regex.*;

class Token {
    enum Type {
        FUNCTION, IDENTIFIER, STRING, NUMBER, OPERATOR, LPAREN, RPAREN, COMMA, EQUAL, UNKNOWN
    }

    Type type;
    String value;

    Token(Type type, String value) {
        this.type = type;
        this.value = value;
    }

    @Override
    public String toString() {
        return type + "('" + value + "')";
    }
}

class Lexer {
    private static final Pattern TOKEN_PATTERNS = Pattern.compile(
            "(?<FUNCTION>[A-Za-z][A-Za-z0-9_]*)" +        // Function names
            "|(?<IDENTIFIER>\\[.*?\\])" +                // Identifiers inside []
            "|(?<STRING>'[^']*')" +                      // Strings like 'avg'
            "|(?<NUMBER>\\d+(\\.\\d+)?)" +               // Numbers (integers or decimals)
            "|(?<EQUAL>=)" +                             // Equal sign
            "|(?<COMMA>,)" +                             // Comma
            "|(?<LPAREN>\\()" +                          // Left Parenthesis
            "|(?<RPAREN>\\))"                            // Right Parenthesis
    );

    private final Matcher matcher;

    Lexer(String input) {
        // Remove extra spaces between tokens, but keep spaces inside []
        input = input.replaceAll("\\s+(?![^\\[]*\\])", "");
        matcher = TOKEN_PATTERNS.matcher(input);
    }

    List<Token> tokenize() {
        List<Token> tokens = new ArrayList<>();
        while (matcher.find()) {
            if (matcher.group("FUNCTION") != null) tokens.add(new Token(Token.Type.FUNCTION, matcher.group()));
            else if (matcher.group("IDENTIFIER") != null) tokens.add(new Token(Token.Type.IDENTIFIER, matcher.group()));
            else if (matcher.group("STRING") != null) tokens.add(new Token(Token.Type.STRING, matcher.group()));
            else if (matcher.group("NUMBER") != null) tokens.add(new Token(Token.Type.NUMBER, matcher.group()));
            else if (matcher.group("EQUAL") != null) tokens.add(new Token(Token.Type.EQUAL, matcher.group()));
            else if (matcher.group("COMMA") != null) tokens.add(new Token(Token.Type.COMMA, matcher.group()));
            else if (matcher.group("LPAREN") != null) tokens.add(new Token(Token.Type.LPAREN, matcher.group()));
            else if (matcher.group("RPAREN") != null) tokens.add(new Token(Token.Type.RPAREN, matcher.group()));
            else tokens.add(new Token(Token.Type.UNKNOWN, matcher.group()));
        }
        return tokens;
    }
}
```

---

### **Test Case**
```java
public class Main {
    public static void main(String[] args) {
        String input = "Function1 ( [var1 var1.var1 var1] , [var2] , 'avg' )\n"
                     + "Function2([var1.var1],[var2] = 'value')\n"
                     + "Function3 ( [var1 var2.var1 var2] , 0 )";

        Lexer lexer = new Lexer(input);
        List<Token> tokens = lexer.tokenize();
        
        System.out.println("Tokens:");
        tokens.forEach(System.out::println);
    }
}
```

---

### **Expected Output**
```
Tokens:
FUNCTION('Function1')
LPAREN('(')
IDENTIFIER('[var1 var1.var1 var1]')
COMMA(',')
IDENTIFIER('[var2]')
COMMA(',')
STRING('avg')
RPAREN(')')
FUNCTION('Function2')
LPAREN('(')
IDENTIFIER('[var1.var1]')
COMMA(',')
IDENTIFIER('[var2]')
EQUAL('=')
STRING('value')
RPAREN(')')
FUNCTION('Function3')
LPAREN('(')
IDENTIFIER('[var1 var2.var1 var2]')
COMMA(',')
NUMBER('0')
RPAREN(')')
```

---

### **Key Fixes**
✅ Spaces between tokens are ignored.  
✅ Spaces inside `[]` are preserved in the identifier.  
✅ Everything else still functions as expected.  

Would you like to extend this further (e.g., support for nested function calls)?

